/*
todo 교육자료 27페이지
  - 클래스이름 부분 : 헤더
  - 클래스 바디 {필드를 속성이라 부느는 이유는 나중에 알게됨}
  지금 작성하는 모든 코드는 코드/텍스트 영역이 있다가 VM이 다른곳으로 할당함
  VM이 하는거 1. void main() 부터 찾음.
  힙 영역에 객체를 생성할려면 기존에는 new 키워드를 사용했는데
  다트에서는 빼버림.(안써도됨)
  final / const 둘다 다름 컴파일 상수 런타임 상수
  >>> 잘 모르겠으면 final로 써도 되긴함
  var로 써서 타입추론을 사용할 수 있지만 타입을 정확히 적어주는게 오류가 적고 공부에 좋음
  -   nullable이 필요한 상황이면 ? 붙임
 */
// todo 오늘 할거

class MyClass {
  // 상수(Constants) : 대문자 + 언더라인으로 명명(Snake 작성법 작성)

  // 필드(Field) == 변수(Variable)/속성(Property)
  //    ㄴ 객체마다 값 부여
  //    ㄴ 정적/클래스 변수 : 클래스명으로 즉각 사용 -> 공유
  //    ㄴ 동적/멤버 변수 : 객체를 생성해야만 사용 -> 객체 개별

  // 생성자(Constructor)
  //    ㄴ 클래스로부터 객체를 생성하는 함수(함수명은 클래스명으로 고정)

  // 메소드(Method) == 함수(Functions)
  //    ㄴ 정적/클래스 메소드 : 클래스명으로 즉각 사용 -> 공유
  //    ㄴ 동적/멤버 메소드 : 객체를 생성해야만 사용 -> 객체 개별

  // 중첩(Nested Class)/내부(Inner) 클래스/인터페이스 : DART 미지원
}

// "동물"이라는 분류를 만듬
class Animal {}
class Person {
// "사람"이라는 분류를 만듬
  //  객체의 의미 3가지
  //  1. Object 로써의 객체 : 모든 객체를 의미 ex) 모든 사물 이다. 일단 통틀어 말하는 말
  //  2. Instance 로써의 객체 : 메인 메모리 상의 객체를 의미함. 컴퓨터의 메모리에 저장된 객체
  //  3. Data(혹은 Entity) 로써의 객체  : 엔터티라고함. 데이터로 만들어져 있는 객체
  //
  //  인스턴스(Instance)?
  //  메인 메모리에 있는 상태의 객체를 말함
  //  (+ 인스턴스화(Instantiate) : 메인메모리에 클래스로부터 객체를 만드는 것)
  //  >>> 인스턴스의 기준은 메인 메모리이다.

  // 객체의 멤버는 두 가지가 있는데
  // 인스턴스 멤버는 객체를 메인 메모리에 만들어져 있어야 사용 가능함.
  // 인스턴스 멤버 : 멤버 변수/함수 (멤버 필드/멤버 메소드)
  // 별도 키워드 없음  => 객체 마다 고유한 값/ 기능 부여
  //                => 힙(Heap) 영역 =>   null 처리 후 제거가 됨
  //                => 객체 사용할 때 까지만 가지고 가고 싶을 때
  //                   (90% 이상 여기에 속하기 될 것)
  //
  // 클래스 멤버 : 정적 변수/함수 (정적 멤버 필드/정적 멤버 메소드) 둘이 다름
  // static 키워드 => 모든 객체가 공유 하는 값/기능 부여
  //              => 코드/텍스트 영역 =>  프로그램 종료 시점에 제거
  //              => 프로그램이 끝날 때 까지 계속 보유하고 싶을 때
  //            (10% 이하 또는 더 적은 쪽임. e.g 상수)
  //              => 상수로 선언 하고 싶을 때 사용함.
  // todo 모두 클래스 멤버로 사용안하는 이유 => 메모리는 한정적이라 애껴써야함.
  // person. 입력 후 내용을 보면,
  // f : 필드
  // p : 속성(필드 + 액세서) => 다르게 말하면 필드는 그냥 값임. 액세서는 메서드임. 프로퍼티는 둘이 결합 한거라고 보면됨. 둘이 다른거.
  // m : 메소드
  /*
  // 초기화 하지 않을 경우 오류
  Non-nullable instance field 'head' must be initialized. (Documentation)  Try adding an initializer expression,
 or a generative constructor that initializes it, or mark it 'late'.
  // 최소한 기초 타입의 기본 값으로 초기화 할 것!
   */
  // 공유 되는 값임
  static int STATE = 10; // 정적 변수  // 스태틱에 점을 찍으면 공유 된다.

  // 초기화 : 이 클래스(Person)로부터 객체가 최초로 생성될 때 가질 값
  int head = 1;
  int hands = 2; // 이 경우 const 타입으로 정의 될 수 있다.
  int legs = 2;
  int body = 1;
  int face = 1;
  int? arm = null; // 값을 주고 싶지 않을 때 이렇게 사용함. 굳이 이렇게 처리할 이유는 없음.
  // 대체로 기본값 하나는 주는게 맞음 ex) int arm = 0;

  // 기능은 곧 함수/메소드
  // 기능 == 함수 / 메소드

  void work() { // Person 클래스의 메소드
    // 기본적으로 변수를 지칭하면, 멤버 변수(필드)를 호출하게 됨
    // 같은 이름의 변수일 경우 우선 순위는
    // 지역변수 > 멤버 변수
    // (스코프에 따른 변수의 우선순위 : 지역 > 외부 > 전역)

    int legs = 3; // 지역변수
    print("${legs}개의 다리로 뜀");

    // this 키워드로 멤버변수를 직접 지칭 가능
    print("${this.legs}개의 다리로 뜀");
    // this 키워드? 현재 객체의 래퍼런스 주소

  }
                    // 객체의 레퍼런스 주소가 복제됨.
  static void speak (Person thiz){

    // 객체의 레퍼런스 주소에 찾아가서 그 멤버변수의 값을 변경시킴
    // => 의도치 않게 외부 효과(Side Effect)를 일으킴
    // thiz.face = 100 ; // 레퍼런스 주소를 찾아 가서 그 멤버변수의 값을 변경 시킴.
    // ㄴ 별로 좋지 못한 방식이다.

    // 추천하는 case
    int face = thiz.face;
    face = 100; // 이렇게 해야 원본을 해치지 않고 사용 가능함. // 이 값은 언제 사용 되고 지워줘야하나? // 이럴때 딱 알려 줄때 고차함수를 사용한다?
    // => 의도치 않게 외부 효과(Side Effect)를 일으킴
    print("${face}개의 얼굴로 말함");
    // 클래스 메소드(정적 메소드) : this를 잃어버림
    // => 이 메소드는 객체 생성 없이도 가능
    // => 인스턴스 멤버는 사용 불가 => 멤버 변수/ 메소드는 사용 불가
    // 그러면 어떻게해야 될까? run() 메소드를 보라
    // print("${face} 개의 얼굴로 말함");// speak 클래스 메소드는 코드/텍스트 영역에 있어서 face 못찾아서 에러

    ("${ thiz.face} 개의 얼굴로 말함");
  }

  // Listener : 리눅스 계통
  // Handler :  윈도우 계통
  // 등록이 언제 될 지 모르겠지만 일단 등록 되면 상황에 대해 일어난 것을 캐치 가능
  // >> 이게 콜백임
  
  void run() {    // void run( void Function on Ran()){ // 달릴때 달린 상황을 알고 싶을때
    // 주석에서 `ignore: ~` 입력하면, Lint에게 경고하는 것 끄라고 지시
    // ignore: unnecessary_this // Alt+ Enter에서 컴파일러에게 무시해라고 하는거
    print("${this.legs} 개의 다리로 걸음"); // this 컴파일러가 불필요하다고 하지만 this로 확실하게 지정해주는게 좋다.
    // 코드가 길어지면 질수록 혼란이 올 수 있으니까.

    // 고차함수/람다 개념을 같이 엮으면 헷갈려지기 시작함
    // => 멤버 메소드 안에서 클래스 메소드를 호출하더라도, 클래스 메소드에서 this를 알 수는 없음.
    // => 클래스 멤버에는 자기자신 레퍼런스 주소(this) 정보는 없음
    //    인스턴스 멤버에는 자기자신 레퍼런스 주소(this) 정보가 있음
    var speak = Person.speak; // 메소드라는 것을 람다라는 것에 넣음. // TODO 이거 공부해야됨
    speak.call(this); // 클래스 메소드를 람다로 가져와서 호출 == > this 정보 없음

    var work = this.work; // 호출 가능함   // TODO 이거 공부해야됨
    work.call(); // 인스턴스 메소드로 람다를 가져와서 호출 == > this 정보 있음
    // 위의 두 가지가 다른 점 : 인스턴스 보유 유무
    some(speak);
    
    // 콜백 : 호출한 쪽 또는 이 상황에 관심있는 객체에게 알려주는 역할
    // onRan();
    
  }
  void onRan(){ // 호출될때까지 기다렸다가 호출되면 실행되고 알려줌
    
  }

  // 클래스 메소드와 고차함수 => 여기서 중요한 것? 클로저 이냐? 아니냐? 개념을 정확히 알고서 사용해야 함
  // => 잘 모르면 메모리 누수
  // 그렇다면 고차함수 스타일은 언제 쓰는게 좋은가요? 콜백용으로 사용하는 것이 좋음
  void some(void Function(Person) fn){
    fn.call(this); //
  }


  void bye() {
    // 내 기준 멤버변수의 값을 100으로 바꿈
    // 이 메소드가 다시 실행되는 시점에는 기존 멤버변수의 값이 100으로 바뀜
    int hands=100;
    print("${hands}");
    // 초기 값을 멤버변수로 사용하게...
    // 람다는 익명함수인데 람다는 함수에다 변수화되어 정의된 것. // 장점. 함수에다 파라미터로 전달이 가능하다. todo 고차함수, 내부함수, 람다 +a 멕시컬스코프(정적 스코프) => 외부 변수 => 클로저
    this.hands = 101;
    print("${ hands }개로 안녕~ 이라고 인사함");

    // 멤버변수를 해치지 않으면서 멤버변수를 사용하는 방법
    // 이렇게하면 멤버변수를 해치지 않으면서 멤버변수를 사용하는 방법임
    // 이 메소드가 다시 실행되는 시점에는 기존 멤버젼수의 값이 그대로 유지됨. 복사가 됨
    // 멤버변수의 값만 복사해서 사용 => 기초타입에서만 해당됨
    int hands1=  this.hands; // 이렇게 짤 수 도 있다. 이유 도 있음
    hands1 =100;// 지금 사용할 때만 100을 바뀜
    print("${ hands}개로 안녕~ 이라고 인사함");
  }
}

// 사과 클래스 정의
class Apple {}

void main() {
// 1개 객체가 들어갈 수 있는 공간만 선언 => 객체 생성이 된 것이 아님
MyClass myClass; // 이 말은 즉, " MyClass myClass = null; " 이나 다름 없다
//  null 이 아닐수도 있다. 그래서 컴파일러가 null로 처리함
myClass = new MyClass(); // 객체 생성을 이렇게 해도 됨. 가능함. | 가능 : 보일러 플레이트 코드 new
// Unnecessary 'new' keyword. (Documentation) <-- 컴파일러는 new가 필요 없다고 함
myClass = MyClass(); // 밑줄이 없음. | 가능 : 생성자 함수를 직접 호출함.
  
  // 여기서 myClass1 객체와 myClass2 객체는 같은가?
  // 아니오. 레퍼런스 주소가 다름 => 클래스 1개당 N개 객체 생성
  // MyClass myClass1 = MyClass();
  // MyClass myClass2 = MyClass();
  // print(MyClass() == MyClass());
  
/* 컴파일러가 알아서 new를 포함시킴
  bin/chapter01/day9_oop2.dart (new) MyClass MyClass()
  Containing class: MyClass
  projects
  >> new 키워드를 사용하면 뜨는 문구
   */

MyClass myClass1 = new MyClass();
MyClass myClass2 =
new MyClass(); // 경우 4가지임 둘다 뺌 : false 둘중 하나만 빼도 false 둘다 포함 : false
// new MyClas() 객체와 MyClass() 객체는 같은가? A : 다르다.
// 레퍼런스 주고가 다르기 때문. => 클래스 1개당 N개의 객체가 생성된다.
// 일단 생성자 함수를 실행한다? 그러면 무조건 객체가 생성된다.

  // ===========================================================

// 다트에선 new를 붙이든 말든 new 를 붙인것 처럼 새로운 객체가 생성된다.
print(myClass1 == myClass2); // false
// 꼬우면 어떨까
MyClass myClass3 = MyClass();
MyClass myClass4 = MyClass();
print(MyClass() == MyClass()); // 이것도 false => 서로 다른 객체라는 말

// 클래스명 == 생성자 가 아니다!
// 구조적 타이핑 언어에서는 클래스명이 곧 생성자 이지만,
// 정적 타이핑 언어에서는 클래스명은 클래스 일 뿐! ( == 타입이다.)
var Type = MyClass; // Type를 가져온 거임
  print(Type.runtimeType);

// 최초에 배웠던 변수 선언과 초기화
// 클래스를 배우고 난 후 변수 선언과 초기화
// 완전히 같음. 다른 부분?
// 최초에 배울 떄는 DART 에서는 기본 지원 하던 타입만 했던 것
// 지금은 새로운 타입(==클래스, 사용자 정의 타입 이라고도 함)을 선언 하고 초기화 한 것.
// - 기초타입(Primitive, Built-in) :  값 정의 타입
// - 사용자 정의 타입(User-Defined) :  유형 정의 타입 // 원칙적으로 다 객체임 다만 동일한 객체라도 값이냐 사용자가 정의 한것에 따라 다름
// Q : 둘의 차이점?

// 선언과 동시에 초기화 하는 형태임
// 변수 선언 + 초기화
Animal animal = Animal();

// 변수 초기화
animal = Animal();

// 직접 생성해보기
Person person = Person();
// person. 입력후 내용을 보면
//   f: 필드
//   p: 속성 + 액세서 => 필드: 값, 액세서: 메소드
//   m: 메소드
// DART에서 변수를 호출하는 방법 ${}

print("${person.head} ${person.face}  ${person.body} ${person.hands} ${person.legs} ");
person.head = 2; // 이 사람 객체는 머리가 두 개가 됨.

Person difPerson = Person(); // 새로운 사람 객체 선언 및 초기화
// 필드는 객체의 고유한 값
person.head == 2;
difPerson.head == 1;
print("${person.head} ${difPerson.head}"); // 2 1 // 객체마다 다른 값을 가짐

// 특정 객체를 명시해서 호출 하려는 경우
// 이 객체에서 해당되는 사함만 인텔리전스(자동완성)에 나타남
// person.
// static 키워드가 있는 필드를 사용 하려면 클래스명을 정확히 지칭 해야 함.
print(Person.STATE); // static 는 자바처럼 클래스 변수?
// p : property, m 메소드 f 필드 점 찍으면 보이는 거.

// 과일 : 사과를 정의 하고 생성 하시오.
Apple apple = Apple();
// todo
// 람다에도 할 수 있지 않을까?
// 람다는 함수의 이름 없이 익명 함수.
var f = Person; // 이거 안됨 // Person은 그냥 타입이라서.
// 여기서 중요. 클래스명이 함수는 아니다. 그냥 클래스명만 쓰면 타입임. 괄호를 붙여야 한다.
// var g = Person();
// f();
// f.call();

// 메소드 호출하기
person.run();
Person.speak(person);


} // END
// 밖에서 코드 작성은 정의 할 때만 사용
// lib 폴더가 없음 materialApp
// 위젯을 사용 할때는 생성자를 적극적으로 사용 한다고 보면 된다.
// 사용할 때마다 다른 객체가 사용 된다.
