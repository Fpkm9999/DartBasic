/// ===========================================================
/// fileName       : dary14_async
/// date           : 2024-02-18
/// description    :
/// - 비동기
///    오래 걸리는 작업, 네트워크 통신 작업 등을 실행시킨 후 완료될 때 콜백으로 수신하는 방법
///
/// > 프로세스 : 1개의 프로그램 = 1개 프로세스
///        그런데 여기에 > N개의 자식 프로세스를 열어줄 수 있음 ( e.g : 크롬)
///                    > 데이터 공유 X -> 데이터 공유를 위해 IPC 통신
///                    > 여기서 처리하는 기술을 멀티프로세싱이라고 함
///
/// > 스레드 :  1개의 프로세스를 N개로 잘라서 사용하는 기술
///           > 실시간 = 시간을 잘게 자름 / 동시성 = 병렬에 가까운 의미
///           > 공유 데이터를 만들어 낼 수 있음 = N 개의 스레드가 동시 접근이 가능해짐
///                                         ㄴ 세마포어 / 뮤텍스 e.g) 화장실 칸
///           > 컨텍스트 스위칭(Context Switching) 가 필요함
///           > 프로세스 내에서 동시에 여러 개 작업을 실행
///           > 멀티스레딩 공부하면 알게 되는 개념들임.
///
///  이제 비동기라는 개념이 들어오는데 그러려면 코루틴을 알아야 함.  // 스레스를 통해 정보를 주고 받는데 이게 불편함 그래서 코루틴이라는 개념 도입
///  > 코루틴 : 컨텍스트 스위칭 없이 1개의 스레드에서 실행시간을 잘라쓰는 기술.
///            > 공유 데이터 가능, 세마포어 / 뮤텍스 같은 동기화 작업 필요 없음(불필요)
///            > 컨텍스트 스위칭 부하 없음
///            > 비동기적 동작
///            > 블럭킹 / 논블러깅 : 함수의 시점
///                   > 블럭킹 : 함수 실행 후 함수 종료까지 대기
///                   > 논블럭킹 : 함수 실행 후 종료를 기다리지 않음
///            > 동기 / 비동기 : OS의 시점
///                > 동기 : 실행이 모두 완료될 떄까지 대기 << 함수에 가까움
///                > 비동기 : 실행이 언젠가는 완료될 것이라고 믿고, 다음 루틴 실행 << 이벤트에 가까움
///                        ( 일반적으로 완료될 때 콜백으로 돌아옴)
///
/// - Dart 에서 프로세싱/스레딩/비동기
///  일단 멀티프로세싱은 된다 : Isolate
///      멀티스레딩은 불가능하다 : Dart/Flutter 는 단일 스레드만 가능(메인 스레드)
///  비동기 가능 : async 키워드 = future 클래스
///
/// 이름중에 worker가 붙은것들은 백그라운드에서 동작함 => 비동기로 동작됨 e.g) isolate
/// ===========================================================

// 동기 함수
void syncFunc() {}
// 비동기 함수
// async vs async*
// async : 일반적으로 이 형태를 가장 많이 볼 것이다.
// async* : 자료구조의 포인터 같은 녀석임. 잘 등장 안함.
Future<void> asyncFunc() async { // 비동기 작업 수행
  /*
      Future
        1. 실행이 완료되어있는 경우 :  결과물 즉각 반환
        2. 실행이 완료되지 않은 경우 :  대기 해있다가 > 완료 시 결과물 반환
   */

  /*
   * await : 비동기 안에서 비동기 함수를 동기로 실행
   *          (async 키워드가 있는 함수 안에서만 사용 가능)
   *
   * then + catchError + whenComplete 로 그냥 하면 안되나요?
   * 가능은 함! 그런데, 콜백 지옥이 될 수 있음
   * await으로 하면, 호출한 비동기 함수가 실행이 완료될 때까지 대기해줌 ( 그래서 비동기를 동기처럼 사용이 가능함)
   */
  void result = await asyncFunc();
}


void main() {

  // 동기 함수 내에서 실행하는 방법
  // 비동기에서 실행되는 구조
  asyncFunc().then((value) {
    /* value : Future 의 제네릭 위치에 선언해놓은 타입의 값(실행 결과 값) */
    /* (실행이 잘 되었을 떄) 성공 시 진입하는 곳*/
  })
      /* 성공 시 진입하는 곳 */
      .catchError((e) {
    /* 예외 발생 시 실행됨 */
  }).whenComplete(() {
    /* 성공 했든/실패 했든 실행이 완료 된 후 실행됨 */
  });
}
